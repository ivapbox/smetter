# Миграции:
* поменял id с varchar(20) на int: если хотим что-то на примере guid'а - можно сделать поле guid
* но здесь нужно понимать: если ручки для "внутреннего использования" - то можно ограничиться id'ами (int)
* если же для внешнего использования - то лучше наверное через guid'ы (но оставить id, а guid уже генерить при создании сущностей)
* bill_type можно сделать enum'ом, но нужно смотреть в контексте: если типы могут часто добавляться, то постоянные миграции - плохая история
* с полем is_paid - сложно, нужно полностью понимать бизнес-логику значения этого поля

# Код:

### Общие замечания:
* use const App\Entity\BILL_TYPE_OTHER; - недопустимо
* Много грязного кода, желательно так: snakeCase - в свойствах, camel_case - в полях массива, константы - FOO_BAR
* Строгая типизация - нужна, тайпхинты - нужны, возвращаемые типы - нужны
* Прописанные @throwable - нужны
* Работа с Entity напоминает работу с Dto, использование ORM сильно упростит код
* Плохая читаемость кода, все разбросано, нет структурированности
* Нет кастомных exception'ов, которые можно пробрасывать и отлавливать узкие ошибочные места
* С репозиториями лучше работать через интерфейсы
* Проверка полей в реквестах - плохая история, чревато проблемами с наличием и типами полей, куда проще сделать аргумент-резолверы, RequestDto, Assert'ы и сериалайзеры/денормалайзеры
* При работе с микросервисами - обязательно оборачивать в try-catch и описывать работы приложения при неработающем микросервисе: другой микросервис не должен нарушить работу приложения


### BillController: 
* Сразу нужно вынести всю логику в сервисы, контроллер должен быть максимально тонким
* Конструкторы в контроллерах не нужны, пробрасываем сервисы через параметры, DI
* В идеале нужны сваггеры, часто их сразу в phpdoc'ах прописывают
* Реквесты желательно "прогнать" через резолверы, получать нужно не Request а нужную Dto, которая уже должна быть провалидирована Assert'ами
* Если мы делаем бэк - то все ответы должны быть в едином формате, без беспорядка (где-то Response, где-то JsonResponse...)
* Более того - ответы нужно передавать со статус-кодами (проверка на 400, 500), соотв. нужны кастомные типы Exception'ов (к примеру BillBadRequestException extends ...)
* Можно даже прописать ExceptionLister'ы, но это уже опционально

### Bill:
* Константы - внутрь класса
* Области видимости - нужны везде
* Лишние зависимости внутри сущностей - не нужны, логика тоже (её в сервисы)

### Item:
* аналогичные замечания, неупорядоченные геттеры/сеттеры (не критично, но для чистоты кода - важно)

### BillFactory:
* Работе с БД здесь не место, для этого есть репозитории
* generateBillId() - непонятно что возвращает, зачем тут datetime
* createBill($data, $id) - нужно переписывать полностью, много уязвимостей, грязный код, нужно использовать сериалайзеры/денормалайзеры (см. выше)

### BillRepository:
* Масса уязвимостей (sql-инъекции, неоптимальный код: много INSERT'ов можно объединить в "чанки", нужны транзакции)

### Отдельное внимание /finish/{billId}: неясно для чего нужен метод, какую логику он выполняет
* $bill->setBillClient(new BillMicroserviceClient()); - не место в entity, более того - что произойдет после выполнения? По сути - ничего


## Также:
* прикладываю пул-реквест возможного исправления
* Его можно продолжить дорабатывать (сериалайзеры/резолверы/листенеры/итдИтп...), в идеале - переписывать весь код:))
* По поводу isPaid: не нужно совмещать логику: "или получаем из таблицы, или из микросервиса" (как минимум потому что он может не работать)
* Также про billUrl: перемешанна логика, можно объединить в единый метод, и там определять - какой url должен возвращаться
* use App\Service\BillGenerator::generate - неясно какие ошибки выбрасывает, нужно прописывать